<h1 id="k8s-overview">k8s overview</h1>

<p>k8s = 複数のホストを束ねてDockerを利用するためのオーケストレーションツール
あたかも1台のサーバのように、透過的にアクセスできる。</p>

<h2 id="主な機能">主な機能</h2>

<ul>
  <li>複数サーバ間でのコンテナ管理</li>
  <li>コンテナ間のネットワーキング</li>
  <li>コンテナの負荷分散</li>
  <li>コンテナの監視</li>
  <li>無停止でのアップデート</li>
</ul>

<h2 id="k8sのサーバ構成">k8sのサーバ構成</h2>

<ul>
  <li>マスターサーバ(kubernetes master)</li>
  <li>データストア(backend database)</li>
  <li>ノード</li>
</ul>

<h3 id="マスタサーバkubernetes-master">マスタサーバ(kubernetes master)</h3>

<ul>
  <li>コンテナを操作するためのサーバ</li>
  <li>kubctlコマンドからのリクエストを受けて処理を行う</li>
  <li>ノードのリソース使用状況を確認してコンテナを起動するノードを選択する</li>
</ul>

<h3 id="データストアbackend-database">データストア(backend database)</h3>

<ul>
  <li>etcdというKVSでクラスタの構成情報を管理</li>
  <li>マスタサーバに構築する構成もありうる</li>
</ul>

<h3 id="ノード">ノード</h3>

<ul>
  <li>コンテナを動作させるサーバ</li>
</ul>

<h2 id="アプリケーションの構成管理">アプリケーションの構成管理</h2>

<ul>
  <li>Pod</li>
  <li>Replica set</li>
  <li>Deployment</li>
</ul>

<h3 id="pod">Pod</h3>

<ul>
  <li>k8sでは複数のコンテナをまとめてPodとして管理する
    <ul>
      <li>webサーバとプロキシなど</li>
    </ul>
  </li>
  <li>Podがデプロイの単位になる
    <ul>
      <li>開始/停止/作成/削除 がpod単位で行われる</li>
    </ul>
  </li>
  <li>Pod(pod内のコンテナ)は同じノードに同時にデプロイされる
    <ul>
      <li>Pod内のコンテナは仮想NICを共有する
        <ul>
          <li>コンテナ同士はlocalhost軽油で通信できる</li>
          <li>共有ディレクトリを介してログ情報をやり取りできる</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="replica-set">Replica set</h3>

<ul>
  <li>k8sクラスタ上で予めpodを作成/起動しておく仕組み
    <ul>
      <li>クラスタ上に決められた数のpodを起動しておく</li>
      <li>起動しておくpodの数をレプリカ数という</li>
    </ul>
  </li>
  <li>Replica setは起動中のpodを監視し、障害など何らかの理由で停止したpodを削除し、新たなpodを起動する</li>
  <li>pod数を同的に変更してオートスケーリングを実現することも可能</li>
</ul>

<h3 id="deployment">Deployment</h3>

<ul>
  <li>PodとReplica setをまとめたもの</li>
  <li>Replica setの履歴を管理するもの
    <ul>
      <li>履歴を管理できるので、コンテナのアップデートやロールバックができる</li>
    </ul>
  </li>
  <li>Replica setのテンプレートを持ち、それに従ってReplica setを作る
    <ul>
      <li>テンプレートでpodの構成を定義する</li>
    </ul>
  </li>
</ul>

<h2 id="ネットワークの管理service">ネットワークの管理(Service)</h2>

<ul>
  <li>Serviceはlocalhostのネットワークを管理するもの</li>
  <li>Podに対して外部からアクセスする時はServiceを定義する</li>
  <li>Serviceにはいくつかの種類がある
    <ul>
      <li>Load Balancer
        <ul>
          <li>Serviceに対応するIPアドレス:ポート番号にアクセスするとL4レベルの負荷分散が行われる</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>サービスによって割り当てられるIPアドレスにはCluster IPとExternal IPがある
    <ul>
      <li>Cluster IPはクラスタ内のPod同士で通信するためのプライベートIPアドレス</li>
      <li>External IPはクラスタ外部から通信するためのパブリックIPアドレス</li>
    </ul>
  </li>
  <li>Podを起動すると、既存のサービスのIPアドレスとポートは環境変数として参照できるようになる</li>
  <li>IngressというPodへの通信を制御する昨日もある
    <ul>
      <li>k8sが動作する環境によって実装が異なる
        <ul>
          <li>GCPの場合はHTTP Load Balanser(L7)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="labelによるリソースの識別">Labelによるリソースの識別</h2>

<ul>
  <li>k8sではリソースを識別するためにランダムな文字列が自動的付与される</li>
  <li>リソースには任意のLabelをつけて管理できる</li>
  <li>Labelはkey-value型の任意の文字列</li>
  <li>サービス定義のSelectorでLabelを指定すると、そのLabelを保つPodのみにリクエストを転送することが可能</li>
</ul>

<h2 id="k8sの仕組み">k8sの仕組み</h2>

<ol>
  <li>Master
    <ul>
      <li>API Server
        <ul>
          <li>フロントエンドのREST API</li>
          <li>各コンポーネントから情報を受け取ってetcdに保存する
            <ul>
              <li>各コンポーネントはREST API経由でetcdの情報にアクセスする</li>
            </ul>
          </li>
          <li>人間はkubctlコマンドはWebのGUIツールからアクセスする</li>
          <li>認証・認可の機能も持つ</li>
        </ul>
      </li>
      <li>Scheduler
        <ul>
          <li>Podをどのノードで動かすか制御するバックエンドコンポーネント</li>
        </ul>
      </li>
      <li>Controller Manager
        <ul>
          <li>k8sクラスタの状態を監視するバックエンドコンポーネント</li>
          <li>定義ファイルで指定したものと実際の状態をまとめて管理する</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Datastore
    <ul>
      <li>k8sクラスタの構成を保持する分散KVS</li>
      <li>APIサーバから参照される</li>
    </ul>
  </li>
  <li>Node
    <ul>
      <li>kublet
        <ul>
          <li>ノードで動作するエージェント</li>
          <li>Dockerコンテナの実行やストレージのマウント機能を持つ</li>
          <li>ノードのステータスを定期的に監視し、ステータスが変わるとAPI Serverに通知する</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
